
import { GoogleGenAI } from "@google/genai";

export async function generateJewelryPhoto(
  base64Image: string,
  placement: string,
  style: string,
  customPrompt: string
): Promise<string[]> {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY || '' });
  
  const base64Data = base64Image.split(',')[1];

  // Professional photography technical suffix to enforce realism
  const realismSuffix = `
    Photographic Style: High-end commercial jewelry photography. 
    Technical: Shot on Hasselblad H6D-100c, 100MP, sharp focus, ultra-high resolution. 
    Lighting: Realistic light behavior, accurate caustic reflections in gemstones, physically correct light falloff. 
    Avoid: Plastic textures, overly smooth surfaces, airbrushed looks, or generic AI artifacts. 
    Goal: Make it look like a RAW, unedited high-fashion photograph.
  `;

  const variants = [
    {
      id: 'closeup',
      label: 'Macro Detail Shot',
      prompt: `Extreme macro photography of the jewelry. Focus on the microscopic details of the stone facets, the refractive index of the gems, and the authentic texture of the metal. Include realistic light dispersion. Neutral background with soft, natural bokeh. 8k, photorealistic. ${customPrompt} ${realismSuffix}`
    },
    {
      id: 'display',
      label: 'Commercial Display',
      prompt: `A professional boutique display shot. The jewelry is placed on a realistic ${style} surface (like heavy marble or fine silk). The metal should show faint, realistic reflections of a high-end studio environment. Cinematic depth of field, sophisticated side-lighting. ${customPrompt} ${realismSuffix}`
    },
    {
      id: 'lifestyle',
      label: 'Editorial Lifestyle',
      prompt: `High-fashion editorial portrait. A woman with realistic skin texture (pores, fine lines, natural features - not airbrushed) wearing the jewelry on her ${placement}. Soft natural window light, organic shadows. The jewelry must interact naturally with the skin, casting small realistic shadows. Vogue aesthetic. ${customPrompt} ${realismSuffix}`
    }
  ];

  try {
    const promises = variants.map(async (variant) => {
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
          parts: [
            {
              inlineData: {
                data: base64Data,
                mimeType: 'image/png',
              },
            },
            {
              text: variant.prompt
            },
          ],
        },
      });

      let imageUrl: string | null = null;
      if (response.candidates?.[0]?.content?.parts) {
        for (const part of response.candidates[0].content.parts) {
          if (part.inlineData) {
            imageUrl = `data:image/png;base64,${part.inlineData.data}`;
            break;
          }
        }
      }
      return imageUrl;
    });

    const results = await Promise.all(promises);
    const finalImages = results.filter((img): img is string => img !== null);

    if (finalImages.length === 0) {
      throw new Error("No images were generated by the model");
    }

    return finalImages;
  } catch (error) {
    console.error("Gemini Multi-Variant Generation Error:", error);
    throw error;
  }
}
